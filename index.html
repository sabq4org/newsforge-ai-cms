<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover, interactive-widget=resizes-content" />
    <title>Ø³Ø¨Ù‚ Ø§Ù„Ø°ÙƒÙŠØ© - Sabq Althakiyah</title>
    
    <!-- Critical error handling script -->
    <script>
      // Emergency error detection and recovery
      let criticalErrors = 0;
      const maxErrors = 5; // Increased threshold for better debugging
      
      // Enhanced error handler with more specific patterns and aggressive response
      window.addEventListener('error', function(e) {
        criticalErrors++;
        console.error('HTML-level error:', e.message, e.filename, e.lineno);
        
        // Quantum-specific error patterns
        const quantumErrorPatterns = [
          'q.context.ambientLight',
          'context.ambientLight',
          'undefined is not an object (evaluating \'q.context',
          'undefined is not an object (evaluating \'K.context',
          'undefined is not an object (evaluating \'O.context',
          'undefined is not an object (evaluating \'P.context'
        ];
        
        const generalErrorPatterns = [
          'forEach is not a function',
          'forEach',
          'tailwind',
          'classGroup',
          "Can't find variable: cn",
          'ChartLine',
          'Trophy',
          'Award',
          'toLowerCase is not a function',
          'toLowerCase',
          'toLocaleDateString is not a function',
          'toLocaleDateString',
          'toLocaleTimeString is not a function',
          'toLocaleTimeString',
          'undefined is not an object',
          'property access',
          't.forEach is not a function',
          'classGroupId',
          'twMerge',
          'TSError',
          'SyntaxError', 
          'ReferenceError'
        ];
        
        // Handle quantum errors immediately and aggressively
        const isQuantumError = quantumErrorPatterns.some(pattern => 
          e.message && e.message.includes(pattern)
        );
        
        if (isQuantumError) {
          console.error('ðŸš¨ QUANTUM ERROR DETECTED:', e.message);
          
          // Immediate quantum recovery
          try {
            window.q = {
              context: {
                ambientLight: 0.5,
                timeOfDay: 'morning',
                userActivity: 'browsing',
                eyeStrain: 'low',
                sessionLength: 0
              },
              reasoning: ['Emergency quantum recovery'],
              colors: {
                accent: '#007acc',
                primary: '#0066cc',
                secondary: '#6c757d'
              }
            };
            
            // Also create backup references
            window.quantumContext = window.q.context;
            window.quantumColors = window.q.colors;
            window.quantumReasoning = window.q.reasoning;
            
            console.log('âœ… Emergency quantum recovery completed');
            
            // Stop error propagation for quantum errors
            e.preventDefault();
            e.stopPropagation();
            return true;
          } catch (recoveryError) {
            console.error('Quantum recovery failed:', recoveryError);
          }
        }
        
        // Handle general errors
        const shouldHandle = generalErrorPatterns.some(pattern => 
          e.message && e.message.toLowerCase().includes(pattern.toLowerCase())
        );
        
        if (shouldHandle && criticalErrors > 3) {
          console.warn('Multiple critical errors detected, initiating protective measures');
        }
      });
      
      // Enhanced promise rejection handler with quantum error protection
      window.addEventListener('unhandledrejection', function(e) {
        console.error('Unhandled promise rejection:', e.reason);
        
        if (e.reason && typeof e.reason === 'object') {
          const message = e.reason.message || e.reason.toString();
          
          // Quantum-specific patterns
          const quantumPatterns = [
            'q.context.ambientLight',
            'context.ambientLight',
            'K.context.ambientLight',
            'O.context.ambientLight',
            'P.context.ambientLight'
          ];
          
          const criticalPatterns = [
            'forEach', 'twMerge', 'clsx', 'toLowerCase', 'toLocaleDateString',
            'TSError', 'SyntaxError', 'ReferenceError'
          ];
          
          // Handle quantum errors in promises
          if (quantumPatterns.some(pattern => message.includes(pattern))) {
            console.error('ðŸš¨ QUANTUM ERROR IN PROMISE:', message);
            
            // Emergency quantum initialization
            try {
              window.q = window.q || {};
              window.q.context = window.q.context || {};
              window.q.context.ambientLight = 0.5;
              window.q.context.timeOfDay = 'morning';
              window.q.context.userActivity = 'browsing';
              window.q.context.eyeStrain = 'low';
              window.q.context.sessionLength = 0;
              window.q.reasoning = ['Promise quantum recovery'];
              window.q.colors = { accent: '#007acc', primary: '#0066cc', secondary: '#6c757d' };
              
              console.log('âœ… Promise quantum recovery completed');
              e.preventDefault();
            } catch (quantumRecoveryError) {
              console.error('Promise quantum recovery failed:', quantumRecoveryError);
            }
          }
          
          if (criticalPatterns.some(pattern => message.toLowerCase().includes(pattern))) {
            console.warn('Promise rejection with critical error - logged for debugging');
          }
        }
      });
      
      // Provide enhanced basic fallbacks immediately
      window.cn = window.cn || function() {
        try {
          return Array.from(arguments).filter(arg => 
            arg && typeof arg === 'string' && arg.trim().length > 0
          ).join(' ');
        } catch {
          return '';
        }
      };
      
      // QUANTUM COLOR ERROR PREVENTION - CRITICAL
      // Prevent "undefined is not an object (evaluating 'q.context.ambientLight')" error
      
      // Create multiple protection layers
      function initializeQuantumSafety() {
        try {
          // Layer 1: Global window.q
          window.q = window.q || {};
          window.q.context = window.q.context || {};
          window.q.context.ambientLight = typeof window.q.context.ambientLight === 'number' ? window.q.context.ambientLight : 0.5;
          window.q.context.timeOfDay = window.q.context.timeOfDay || 'morning';
          window.q.context.userActivity = window.q.context.userActivity || 'browsing';
          window.q.context.eyeStrain = window.q.context.eyeStrain || 'low';
          window.q.context.sessionLength = typeof window.q.context.sessionLength === 'number' ? window.q.context.sessionLength : 0;
          
          // Ensure reasoning array exists
          window.q.reasoning = Array.isArray(window.q.reasoning) ? window.q.reasoning : ['Safe quantum adaptation'];
          
          // Ensure colors object exists
          window.q.colors = window.q.colors || {};
          window.q.colors.accent = window.q.colors.accent || '#007acc';
          window.q.colors.primary = window.q.colors.primary || '#0066cc';
          window.q.colors.secondary = window.q.colors.secondary || '#6c757d';
          
          // Layer 2: Global fallback variables for any minified variable conflicts
          window.quantumContext = window.quantumContext || window.q.context;
          window.quantumColors = window.quantumColors || window.q.colors;
          window.quantumReasoning = window.quantumReasoning || window.q.reasoning;
          
          // Layer 3: Create backup safe access functions
          window.getQuantumContext = function() {
            return window.q?.context || {
              ambientLight: 0.5,
              timeOfDay: 'morning',
              userActivity: 'browsing',
              eyeStrain: 'low',
              sessionLength: 0
            };
          };
          
          window.getQuantumColors = function() {
            return window.q?.colors || {
              accent: '#007acc',
              primary: '#0066cc',
              secondary: '#6c757d'
            };
          };
          
          window.getQuantumReasoning = function() {
            return window.q?.reasoning || ['Safe quantum adaptation'];
          };
          
          // Layer 4: Protect against property access on undefined
          const originalDescriptor = Object.getOwnPropertyDescriptor(window, 'q');
          if (!originalDescriptor || originalDescriptor.configurable) {
            try {
              Object.defineProperty(window, 'q', {
                get: function() {
                  return window._quantumObject || (window._quantumObject = {
                    context: {
                      ambientLight: 0.5,
                      timeOfDay: 'morning',
                      userActivity: 'browsing',
                      eyeStrain: 'low',
                      sessionLength: 0
                    },
                    reasoning: ['Safe quantum adaptation'],
                    colors: {
                      accent: '#007acc',
                      primary: '#0066cc',
                      secondary: '#6c757d'
                    }
                  });
                },
                set: function(value) {
                  if (value && typeof value === 'object') {
                    window._quantumObject = value;
                  }
                },
                configurable: true,
                enumerable: true
              });
            } catch (defineError) {
              console.warn('Could not define quantum property descriptor:', defineError);
              // Fallback to direct assignment
              window.q = window.q || {
                context: {
                  ambientLight: 0.5,
                  timeOfDay: 'morning',
                  userActivity: 'browsing',
                  eyeStrain: 'low',
                  sessionLength: 0
                },
                reasoning: ['Safe quantum adaptation'],
                colors: {
                  accent: '#007acc',
                  primary: '#0066cc',
                  secondary: '#6c757d'
                }
              };
            }
          }
          
          console.log('Multi-layer quantum color protection initialized');
          return true;
        } catch (error) {
          console.error('Quantum safety initialization failed:', error);
          // Emergency fallback
          window._emergencyQuantum = {
            context: { ambientLight: 0.5, timeOfDay: 'morning', userActivity: 'browsing', eyeStrain: 'low', sessionLength: 0 },
            reasoning: ['Emergency quantum fallback'],
            colors: { accent: '#007acc', primary: '#0066cc', secondary: '#6c757d' }
          };
          return false;
        }
      }
      
      // Initialize immediately
      initializeQuantumSafety();
      
      // Reinitialize periodically
      setInterval(function() {
        if (!window.q || !window.q.context || typeof window.q.context.ambientLight !== 'number') {
          console.warn('Quantum object corruption detected, reinitializing...');
          initializeQuantumSafety();
        }
      }, 2000);
      
      // Enhanced Array.prototype.forEach safety (early protection)
      if (Array.prototype.forEach) {
        const originalForEach = Array.prototype.forEach;
        Array.prototype.forEach = function(callback, thisArg) {
          try {
            if (!Array.isArray(this)) {
              console.warn('forEach called on non-array, converting');
              return Array.from(this || []).forEach(callback, thisArg);
            }
            return originalForEach.call(this, callback, thisArg);
          } catch (error) {
            console.error('forEach error in HTML safety wrapper:', error);
            // Manual iteration fallback
            for (let i = 0; i < (this?.length || 0); i++) {
              try {
                if (this[i] !== undefined) {
                  callback.call(thisArg, this[i], i, this);
                }
              } catch (itemError) {
                console.error('Error in forEach iteration:', itemError);
              }
            }
          }
        };
      }
      
      // String.prototype.toLowerCase safety
      if (String.prototype.toLowerCase) {
        const originalToLowerCase = String.prototype.toLowerCase;
        String.prototype.toLowerCase = function() {
          try {
            if (typeof this !== 'string') {
              return String(this).toLowerCase();
            }
            return originalToLowerCase.call(this);
          } catch (error) {
            console.error('toLowerCase error:', error);
            return String(this).replace(/[A-Z]/g, char => 
              String.fromCharCode(char.charCodeAt(0) + 32)
            );
          }
        };
      }
      
      // Date.prototype methods safety
      if (Date.prototype.toLocaleDateString) {
        const originalToLocaleDateString = Date.prototype.toLocaleDateString;
        Date.prototype.toLocaleDateString = function(locales, options) {
          try {
            if (!(this instanceof Date) || isNaN(this.getTime())) {
              console.warn('toLocaleDateString called on invalid date');
              return new Date().toLocaleDateString(locales, options);
            }
            return originalToLocaleDateString.call(this, locales, options);
          } catch (error) {
            console.warn('toLocaleDateString error, using fallback:', error);
            return this.getFullYear() + '-' + 
                   String(this.getMonth() + 1).padStart(2, '0') + '-' + 
                   String(this.getDate()).padStart(2, '0');
          }
        };
      }
      
      if (Date.prototype.toLocaleTimeString) {
        const originalToLocaleTimeString = Date.prototype.toLocaleTimeString;
        Date.prototype.toLocaleTimeString = function(locales, options) {
          try {
            if (!(this instanceof Date) || isNaN(this.getTime())) {
              console.warn('toLocaleTimeString called on invalid date');
              return new Date().toLocaleTimeString(locales, options);
            }
            return originalToLocaleTimeString.call(this, locales, options);
          } catch (error) {
            console.warn('toLocaleTimeString error, using fallback:', error);
            return String(this.getHours()).padStart(2, '0') + ':' + 
                   String(this.getMinutes()).padStart(2, '0') + ':' + 
                   String(this.getSeconds()).padStart(2, '0');
          }
        };
      }
      
      console.log('Enhanced critical error handling initialized for Sabq Althakiyah');
      
      // Debug mode indicator
      const urlParams = new URLSearchParams(window.location.search);
      const currentMode = urlParams.get('diagnostic') ? 'Diagnostic' :
                         urlParams.get('simple') ? 'Simple Test' :
                         urlParams.get('emergency') ? 'Emergency' :
                         urlParams.get('minimal') ? 'Minimal' :
                         urlParams.get('safe') ? 'Safe' :
                         urlParams.get('test') ? 'Test' : 'Full Application';
      
      console.log('Current application mode:', currentMode);
      
      // Add mode indicator to page
      setTimeout(() => {
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          position: fixed;
          top: 10px;
          left: 10px;
          background: rgba(0,0,0,0.8);
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-family: 'IBM Plex Sans Arabic', Arial, sans-serif;
          font-size: 12px;
          z-index: 10000;
          pointer-events: none;
        `;
        indicator.textContent = `Mode: ${currentMode}`;
        document.body.appendChild(indicator);
        
        // Remove after 3 seconds
        setTimeout(() => {
          if (indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
          }
        }, 3000);
      }, 1000);
    </script>
    
    <!-- Optimized font loading with preconnect and preload -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Preload critical font files for faster loading -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@300;400;500;600;700&display=swap" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style">
    
    <!-- Load fonts with optimized display strategy -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@300;400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link href="/src/main.css" rel="stylesheet" />
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
