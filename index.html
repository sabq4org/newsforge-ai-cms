<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover, interactive-widget=resizes-content" />
    <title>سبق الذكية - Sabq Althakiyah</title>
    
    <!-- Critical error handling script -->
    <script>
      // Emergency error detection and recovery
      let criticalErrors = 0;
      const maxErrors = 5; // Increased threshold for better debugging
      
      // Enhanced error handler with more specific patterns
      window.addEventListener('error', function(e) {
        criticalErrors++;
        console.error('HTML-level error:', e.message, e.filename, e.lineno);
        
        const errorPatterns = [
          'forEach is not a function',
          'forEach',
          'tailwind',
          'classGroup',
          "Can't find variable: cn",
          'ChartLine',
          'Trophy',
          'Award',
          'toLowerCase is not a function',
          'toLowerCase',
          'toLocaleDateString is not a function',
          'toLocaleDateString',
          'toLocaleTimeString is not a function',
          'toLocaleTimeString',
          'undefined is not an object',
          'property access',
          't.forEach is not a function',
          'classGroupId',
          'twMerge',
          'TSError',
          'SyntaxError', 
          'ReferenceError'
        ];
        
        const shouldRedirect = errorPatterns.some(pattern => 
          e.message && e.message.toLowerCase().includes(pattern.toLowerCase())
        );
        
        // Only redirect if we have more than maxErrors or the user manually requests it
        if (criticalErrors > maxErrors) {
          console.warn('Too many critical errors, consider using diagnostic mode');
          // Don't auto-redirect to prevent endless loops
        }
      });
      
      // Enhanced promise rejection handler
      window.addEventListener('unhandledrejection', function(e) {
        console.error('Unhandled promise rejection:', e.reason);
        
        if (e.reason && typeof e.reason === 'object') {
          const message = e.reason.message || e.reason.toString();
          const criticalPatterns = [
            'forEach', 'twMerge', 'clsx', 'toLowerCase', 'toLocaleDateString',
            'TSError', 'SyntaxError', 'ReferenceError'
          ];
          
          if (criticalPatterns.some(pattern => message.toLowerCase().includes(pattern))) {
            console.warn('Promise rejection with critical error - logged for debugging');
            // Don't auto-redirect to prevent endless loops
          }
        }
      });
      
      // Provide enhanced basic fallbacks immediately
      window.cn = window.cn || function() {
        try {
          return Array.from(arguments).filter(arg => 
            arg && typeof arg === 'string' && arg.trim().length > 0
          ).join(' ');
        } catch {
          return '';
        }
      };
      
      // QUANTUM COLOR ERROR PREVENTION - CRITICAL
      // Prevent "undefined is not an object (evaluating 'q.context.ambientLight')" error
      window.q = window.q || {};
      window.q.context = window.q.context || {};
      window.q.context.ambientLight = window.q.context.ambientLight || 0.5;
      window.q.context.timeOfDay = window.q.context.timeOfDay || 'morning';
      window.q.context.userActivity = window.q.context.userActivity || 'browsing';
      window.q.context.eyeStrain = window.q.context.eyeStrain || 'low';
      window.q.context.sessionLength = window.q.context.sessionLength || 0;
      
      // Ensure reasoning array exists
      window.q.reasoning = window.q.reasoning || ['Safe quantum adaptation'];
      
      // Ensure colors object exists
      window.q.colors = window.q.colors || {};
      window.q.colors.accent = window.q.colors.accent || '#007acc';
      window.q.colors.primary = window.q.colors.primary || '#0066cc';
      window.q.colors.secondary = window.q.colors.secondary || '#6c757d';
      
      console.log('Quantum color context initialized safely');
      
      // Enhanced Array.prototype.forEach safety (early protection)
      if (Array.prototype.forEach) {
        const originalForEach = Array.prototype.forEach;
        Array.prototype.forEach = function(callback, thisArg) {
          try {
            if (!Array.isArray(this)) {
              console.warn('forEach called on non-array, converting');
              return Array.from(this || []).forEach(callback, thisArg);
            }
            return originalForEach.call(this, callback, thisArg);
          } catch (error) {
            console.error('forEach error in HTML safety wrapper:', error);
            // Manual iteration fallback
            for (let i = 0; i < (this?.length || 0); i++) {
              try {
                if (this[i] !== undefined) {
                  callback.call(thisArg, this[i], i, this);
                }
              } catch (itemError) {
                console.error('Error in forEach iteration:', itemError);
              }
            }
          }
        };
      }
      
      // String.prototype.toLowerCase safety
      if (String.prototype.toLowerCase) {
        const originalToLowerCase = String.prototype.toLowerCase;
        String.prototype.toLowerCase = function() {
          try {
            if (typeof this !== 'string') {
              return String(this).toLowerCase();
            }
            return originalToLowerCase.call(this);
          } catch (error) {
            console.error('toLowerCase error:', error);
            return String(this).replace(/[A-Z]/g, char => 
              String.fromCharCode(char.charCodeAt(0) + 32)
            );
          }
        };
      }
      
      // Date.prototype methods safety
      if (Date.prototype.toLocaleDateString) {
        const originalToLocaleDateString = Date.prototype.toLocaleDateString;
        Date.prototype.toLocaleDateString = function(locales, options) {
          try {
            if (!(this instanceof Date) || isNaN(this.getTime())) {
              console.warn('toLocaleDateString called on invalid date');
              return new Date().toLocaleDateString(locales, options);
            }
            return originalToLocaleDateString.call(this, locales, options);
          } catch (error) {
            console.warn('toLocaleDateString error, using fallback:', error);
            return this.getFullYear() + '-' + 
                   String(this.getMonth() + 1).padStart(2, '0') + '-' + 
                   String(this.getDate()).padStart(2, '0');
          }
        };
      }
      
      if (Date.prototype.toLocaleTimeString) {
        const originalToLocaleTimeString = Date.prototype.toLocaleTimeString;
        Date.prototype.toLocaleTimeString = function(locales, options) {
          try {
            if (!(this instanceof Date) || isNaN(this.getTime())) {
              console.warn('toLocaleTimeString called on invalid date');
              return new Date().toLocaleTimeString(locales, options);
            }
            return originalToLocaleTimeString.call(this, locales, options);
          } catch (error) {
            console.warn('toLocaleTimeString error, using fallback:', error);
            return String(this.getHours()).padStart(2, '0') + ':' + 
                   String(this.getMinutes()).padStart(2, '0') + ':' + 
                   String(this.getSeconds()).padStart(2, '0');
          }
        };
      }
      
      console.log('Enhanced critical error handling initialized for Sabq Althakiyah');
      
      // Debug mode indicator
      const urlParams = new URLSearchParams(window.location.search);
      const currentMode = urlParams.get('diagnostic') ? 'Diagnostic' :
                         urlParams.get('simple') ? 'Simple Test' :
                         urlParams.get('emergency') ? 'Emergency' :
                         urlParams.get('minimal') ? 'Minimal' :
                         urlParams.get('safe') ? 'Safe' :
                         urlParams.get('test') ? 'Test' : 'Full Application';
      
      console.log('Current application mode:', currentMode);
      
      // Add mode indicator to page
      setTimeout(() => {
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          position: fixed;
          top: 10px;
          left: 10px;
          background: rgba(0,0,0,0.8);
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-family: 'IBM Plex Sans Arabic', Arial, sans-serif;
          font-size: 12px;
          z-index: 10000;
          pointer-events: none;
        `;
        indicator.textContent = `Mode: ${currentMode}`;
        document.body.appendChild(indicator);
        
        // Remove after 3 seconds
        setTimeout(() => {
          if (indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
          }
        }, 3000);
      }, 1000);
    </script>
    
    <!-- Optimized font loading with preconnect and preload -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Preload critical font files for faster loading -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@300;400;500;600;700&display=swap" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style">
    
    <!-- Load fonts with optimized display strategy -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@300;400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link href="/src/main.css" rel="stylesheet" />
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
